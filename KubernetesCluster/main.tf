
# ======================================================
# Creates an AKS Admin Public Key
# ======================================================
// Important Security Notice 
// The private key generated by this resource will be stored unencrypted in your Terraform state file. 
// Use of this resource for production deployments is not recommended. 
//
// Instead, generate a private key file outside of Terraform and distribute it securely 
// to the system where Terraform will be run.

// for testing purpose (only in anteprod envs), uncomment these lines :
module "aks_admin_tls_private_key" {

  resource_deploy = var.resource_deploy
  source          = "../SshKey/" 

  ssh_algorithm   = var.resource_deploy ? "RSA" : ""
  ssh_ecdsa_curve = var.resource_deploy ? "P224" : ""
  ssh_rsa_bits    = var.resource_deploy ? 4096 : null

}

# ======================================================
# Creates AKS Cluster
# ======================================================
resource "azurerm_kubernetes_cluster" "aks" {
  count               = (var.resource_deploy ? 1 : 0)
  name                = local.resource_name // var.aks_name
  location            = data.azurerm_resource_group.project_resource_group.location
  resource_group_name = data.azurerm_resource_group.project_resource_group.name
  dns_prefix          = var.aks_dns_prefix
  kubernetes_version  = var.aks_version // // var.aks_version != "" ? var.aks_version : data.azurerm_kubernetes_service_versions.current.latest_version

  // RBAC enabled
  role_based_access_control {
    enabled = true
    azure_active_directory {
      client_app_id     = data.azurerm_key_vault_secret.aks-aad-client-app-id.value  // var.aks_rbac_aad_client_app_id
      server_app_id     = data.azurerm_key_vault_secret.aks-aad-server-app-id.value  // var.aks_rbac_aad_server_app_id
      server_app_secret = data.azurerm_key_vault_secret.aks-aad-server-app-psw.value // var.aks_rbac_aad_server_app_secret
      tenant_id         = data.azurerm_client_config.current.tenant_id
    }
  }

  // linux_profile block for testing
  linux_profile {
    admin_username = local.aks_admin_target_username
    ssh_key {
      // (Required) The Public SSH Key used to access the cluster
      key_data = trimspace(replace(module.aks_admin_tls_private_key.public_key_openssh[0], "\n", ""))
    }
  }
  // Important Security Notice / SSH Keys BEST PRACTICES : 
  //  - The private key generated by this resource will be stored unencrypted in your Terraform state file. 
  //  - Use of this resource for production deployments is not recommended. 
  //  - Instead, generate a private key file outside of Terraform and distribute it securely 
  //    to the system where Terraform will be run.
  //  - more info here for the best practices to implement : https://docs.microsoft.com/en-us/azure/aks/ssh

// addon_profile for the target
  addon_profile {
    # http_application_routing {
    #   enabled = false // simple conf to test
    # }
      // http application routing
    dynamic "http_application_routing" {
      for_each = lookup(var.aks_addon_profile, "http_application_routing_enabled", false) == true ? [1] : []
      content {
        enabled = var.aks_addon_profile.http_application_routing_enabled
      }
    }
    // oms_agent block to enable Azure Monitor for containers (should be true in the target)
    # dynamic "oms_agent" {
    #   for_each = lookup(var.aks_addon_profile, "oms_agent_enabled", false) == true ? [1] : []
    #   content {
    #     enabled                    = var.aks_addon_profile.oms_agent_enabled
    #     log_analytics_workspace_id = module.aks_law.law_id //var.aks_monitoring_log_analytics_workspace_id
    #   }
    # }
    // aks kube dashboard
    dynamic "kube_dashboard" {
      for_each = lookup(var.aks_addon_profile, "kube_dashboard_enabled", false) == true ? [1] : []
      content {
        enabled = var.aks_addon_profile.kube_dashboard_enabled
      }
    }
  }

  // default_node_pool block for testing
  default_node_pool {
    name            = "nodepool00"
    node_count      = var.aks_agent_count
    vm_size         = var.aks_agent_vm_size
    os_disk_size_gb = var.aks_agent_os_disk_size
    vnet_subnet_id  = var.aks_vnet_subnet_id
  }
  // default_node_pool block for the target
#   default_node_pool {
#     vnet_subnet_id      = azurerm_subnet.aks_subnet[0].id
#     name                = substr(var.default_node_pool.name, 0, 12)
#     node_count          = var.default_node_pool.node_count
#     vm_size             = var.default_node_pool.vm_size
#     type                = "VirtualMachineScaleSets"
#     availability_zones  = var.default_node_pool.zones
#     max_pods            = 250
#     os_disk_size_gb     = 128
#     node_taints         = var.default_node_pool.taints
#     enable_auto_scaling = var.default_node_pool.cluster_auto_scaling
#     min_count           = var.default_node_pool.cluster_auto_scaling_min_count
#     max_count           = var.default_node_pool.cluster_auto_scaling_max_count
#  }

  service_principal {
    client_id     = data.azurerm_key_vault_secret.aks-sp-client-id.value // var.aks_sp_client_id
    client_secret = data.azurerm_key_vault_secret.aks-sp-psw.value       // var.aks_sp_secret
  }

  // network_profile block for testing
  network_profile {
    network_plugin     = "azure"
    dns_service_ip     = var.aks_dns_service_ip
    docker_bridge_cidr = var.aks_docker_bridge_cidr
    service_cidr       = var.aks_service_cidr
  }

  // **********************************************************************************
  // FOR THE TARGET : Deploy a private AKS cluster 
  // to ensure ensure that network traffic between API server your node pools remains 
  // on the private network only.
  // Be aware of the Private AKS cluster limitations :
  // https://docs.microsoft.com/en-us/azure/aks/private-clusters#limitations
  // **********************************************************************************
  # dynamic "network_profile" {
  #   for_each = var.aks_network_profile  == "" ? [] : [1] // return empty list to for_each if var.aks_network_profile is empty
  #   content {
  #     network_plugin     = var.aks_network_profile.network_plugin
  #     network_policy     = var.aks_network_profile.network_policy
  #     service_cidr       = var.aks_network_profile.service_cidr
  #     dns_service_ip     = var.aks_network_profile.dns_service_ip
  #     docker_bridge_cidr = var.aks_network_profile.docker_bridge_cidr
  #     load_balancer_sku  = lookup(var.aks_network_profile, "load_balancer_sku", "basic") //basic if load_balancer_sku is not set
  #   }
  # }

  depends_on = [var.resource_depends_on]
  
}
